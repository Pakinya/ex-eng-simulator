import type { IConsoleStore, UThreads, IConsoleLogIn, RenderableProps } from '@store/console'
import { useConsoleStore } from '@store/console'

type IEventsRestriction<IEvents> = {
  [key in keyof IEvents]: unknown
}

type UEventName<IEvents> = keyof IEvents
type TListener<IEvents, EventName extends UEventName<IEvents>, ReturnType = void> = ( args: IEvents[EventName] ) => ReturnType
type IListeners<IEvents, ReturnType = void> = {
  [EventName in UEventName<IEvents>]: ( TListener<IEvents, EventName, ReturnType> )[]
}

export class EventEmitter<IEvents extends IEventsRestriction<IEvents>> {
  private listeners = {} as Partial<IListeners<IEvents>>

  on<EventName extends UEventName<IEvents>>( event: EventName, handler: TListener<IEvents, EventName> ): TListener<IEvents, EventName> {
    const handlers = this.listeners[ event ]

    if ( handlers ) {
      handlers.push( handler )
    } else {
      this.listeners[ event ] = [ handler ]
    }

    return handler
  }

  off<EventName extends UEventName<IEvents>>( event: EventName, handler: TListener<IEvents, EventName> | string ): true | void {
    const handlers = this.listeners[ event ]

    if ( handlers ) {
      const removeIndex = handlers.findIndex( ( eventHandler ) => eventHandler === handler || eventHandler.name === handler )

      if ( removeIndex !== -1 ) {
        handlers.splice( removeIndex, 1 )
        return true
      }
    }
  }


  notify<EventName extends UEventName<IEvents>>( event: EventName, args: IEvents[EventName] ) {
    const handlers = this.listeners[ event ]

    if ( handlers ) {
      let handler: TListener<IEvents, EventName>
      for ( handler of handlers ) {
        handler( args )
      }
    } 
  }
}

export interface IEventEmitterOwner<IEvents extends IEventsRestriction<IEvents>, Emitter extends InstanceType<typeof EventEmitter<IEvents>> = InstanceType<typeof EventEmitter<IEvents>>> {
  on<Args extends Parameters<Emitter['on']>> ( event: Args[0], handler: Args[1] ): ReturnType<Emitter['on']>; 
  off<Args extends Parameters<Emitter['off']>> ( event: Args[0], handler: Args[1] ): ReturnType<Emitter['off']>; 
}

// ------------ STORE CONNECTOR ------------
type IStoreConnectorRenderDesc<IEvents extends IEventsRestriction<IEvents>, EventName extends keyof IEvents> = Required<{
  [Prop in RenderableProps['URequired']]: TListener<IEvents, EventName, string>
}> & Partial<{
  [Prop in RenderableProps['UPartial']]: TListener<IEvents, EventName, string>
}> & {
  setEventBasedProps: ( logRenderablePartial: IConsoleLogRenderablePartial ) => IConsoleLogIn;
}

export type IStoreConnectorRestriction<IEvents> = {
  [EventName in UEventName<IEvents>]: IStoreConnectorRenderDesc<IEvents, EventName>
}

type IConsoleLogRenderablePartial = Pick<IConsoleLogIn, RenderableProps['URequired'] | RenderableProps['UPartial'] | 'autogenerated'> 

export class StoreConnector<IEvents, IStoreConnector extends IStoreConnectorRestriction<IEvents>, Thread extends UThreads > {
  private _thread: Thread
  private  _renderSchema: IStoreConnector
  private _eventEmitter: InstanceType<typeof EventEmitter<IEvents>> | IEventEmitterOwner<IEvents>
  private _store: IConsoleStore
  private _listeners = {} as IListeners<IEvents>

  constructor( thread: Thread, renderSchema: IStoreConnector, eventEmitter: InstanceType<typeof EventEmitter<IEvents>> | IEventEmitterOwner<IEvents> ) {
    this._thread = thread
    this._renderSchema = renderSchema
    this._eventEmitter = eventEmitter
    this._store = useConsoleStore()
    this.generateListeners()
    this.startListeningEvents()
  }

  private generateListeners() {
    const events: UEventName<IEvents>[] = Object.keys( this._renderSchema ) as UEventName<IEvents>[]
    
    let event: UEventName<IEvents>
    for ( event of events ) {
      const renderInstructions = this._renderSchema[ event ] as IStoreConnectorRenderDesc<IEvents, typeof event>

      this._listeners[ event ] = [
        ( args ): void => {
          const renderableLogPartial: IConsoleLogRenderablePartial = {
            autogenerated: true,
            title: renderInstructions.title( args ),
            text: renderInstructions.text ? ( renderInstructions.text )( args ) : null,
          }

          const log = renderInstructions.setEventBasedProps( renderableLogPartial )
          this._store.log( this._thread, log )
        
        },
      ]
    }
  }

  private startListeningEvents() {
    const events = Object.keys( this._listeners ) as UEventName<IEvents>[]
    let event: UEventName<IEvents>
    for ( event of events ) {
      const listener = this._listeners[ event ][ 0 ]
      ;( this._eventEmitter.on as <EventName extends UEventName<IEvents>>( event: EventName, handler: TListener<IEvents, EventName> ) => TListener<IEvents, EventName> )( event, listener ) 
    }
  }
}


